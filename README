ğŸ›¡ CryptoApp GUI

CryptoApp GUI es una aplicaciÃ³n escrita en Python que permite experimentar y trabajar con diversos mecanismos criptogrÃ¡ficos modernos a travÃ©s de una interfaz grÃ¡fica intuitiva. Es ideal tanto para entornos educativos como profesionales, facilitando tareas como:

Cifrado y descifrado simÃ©trico y asimÃ©trico.

GeneraciÃ³n de HMAC y hash.

Firma digital y verificaciÃ³n.

DerivaciÃ³n segura de claves con sal (salt).

Su objetivo es acercar la criptografÃ­a prÃ¡ctica a estudiantes, analistas de ciberseguridad (Blue Team), desarrolladores y entusiastas que deseen proteger informaciÃ³n sensible de forma accesible.

âš™ Requisitos del sistema

ğŸ Python

Python >= 3.10

ğŸ“¦ Dependencias

InstÃ¡lalas con pip:

pip install pycryptodome cryptography pyperclip

â–¶ EjecuciÃ³n

python "CryptoApp_GUI.py"

âœ³ Funcionalidades

Cifrado simÃ©trico con AES (CBC/GCM), ChaCha20, ChaCha20-Poly1305

Cifrado asimÃ©trico con RSA

Firma digital y verificaciÃ³n con clave pÃºblica

Hashing con SHA-256, SHA-512, SHA3-256, SHA3-512

HMAC

DerivaciÃ³n de claves mediante PBKDF2 + Salt

GeneraciÃ³n y almacenamiento seguro de claves

ğŸ§ª Ejemplos paso a paso

1. ğŸ” Cifrado SimÃ©trico con AES-CBC + PKCS7

Objetivo: Cifrar un mensaje con una clave generada y un nonce aleatorio.

Pasos:

En "Cifrado SimÃ©trico":

Escribe: La contraseÃ±a de acceso es 4fTu#92x!

Pulsa "Generate Key"

Pulsa "Generate Nonce"

Selecciona AES-CBC y PKCS7

Pulsa Encrypt

Resultado: Texto cifrado en base64

![image](https://github.com/user-attachments/assets/0b856036-fbcf-4d9d-9ec8-3d24b96ba3a8)


2. ğŸ” HMAC con SHA256

Objetivo: Generar una firma HMAC para verificar integridad del mensaje original.

Pasos:

En "Hashing y HMAC":

Pega el mismo mensaje: La contraseÃ±a de acceso es 4fTu#92x!

Usa la misma clave que en el paso anterior.

Selecciona sha256

Pulsa HMAC

Resultado: CÃ³digo HMAC SHA256

![image](https://github.com/user-attachments/assets/f9473d2a-8510-404b-a51e-ee18094353c8)




3. ğŸ” Cifrado AsimÃ©trico RSA

Objetivo: Enviar un mensaje cifrado con clave pÃºblica, que solo puede ser descifrado con la clave privada.

Pasos:

Pulsa Generate Key Pair y guarda:

Clave privada: private_key.pem

Clave pÃºblica: public_key.pem

Escribe el mensaje:

Este mensaje estÃ¡ cifrado con clave pÃºblica RSA.

Selecciona el archivo .pem de la clave pÃºblica

Pulsa Encrypt

Copia el resultado cifrado

En el campo "Message", pÃ©galo

Selecciona private_key.pem y pulsa Decrypt

Resultado: El mensaje original descifrado correctamente

![image](https://github.com/user-attachments/assets/3fa9e04c-e1fd-4978-998f-1c160486fbb0)
![image](https://github.com/user-attachments/assets/6dbba0b7-e3c4-4946-99ed-de40022f84fe)
![image](https://github.com/user-attachments/assets/042b8fb4-2858-452a-bb00-19333bca0fa4)





4. ğŸ§¬ DerivaciÃ³n de claves seguras (PBKDF2)

Objetivo: Derivar una clave criptogrÃ¡fica fuerte desde una clave maestra y una sal (salt).

Pasos:

En "GestiÃ³n de Claves":

Selecciona Key Size: 256

Pulsa Generate Master Key

Pulsa Generate Salt

Pulsa Derive Key

Resultado: Clave derivada lista para usar

![image](https://github.com/user-attachments/assets/1406b7e6-7a57-4f04-b20a-a5e02e0e8b3e)


ğŸ” Guardar clave generada

Pulsa Save Key para almacenar en .key

Puedes cargarla luego con Load Key

![image](https://github.com/user-attachments/assets/d1a7a8d2-7819-4c23-b557-a5a8f06722d5)


ğŸ’¼ Casos de uso reales

Cifrado de mensajes y datos confidenciales

VerificaciÃ³n de integridad con HMAC

ProtecciÃ³n de contraseÃ±as con derivaciÃ³n PBKDF2

SimulaciÃ³n de envÃ­o seguro usando RSA

Aprendizaje y formaciÃ³n en criptografÃ­a aplicada


ğŸ”— Autor

Daniel (@U7Dani)GitHub: https://github.com/U7Dani

